<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Standard Grammars for LTL and LDL</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="css/pandoc.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Standard Grammars for LTL and LDL (v0.1.0)</h1>
<p class="author">Marco Favorito<br>
Department of Computer, Control and Management Engineering<br>
Sapienza University of Rome<br>
Via Ariosto, 25, 00185 Roma RM, Italy<br>
<a href="mailto:favorito@diag.uniroma1.it">favorito@diag.uniroma1.it</a><br>
<a href="https://marcofavorito.me">https://marcofavorito.me</a>
</p>
</header>
<nav id="TOC">
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a><ul>
<li><a href="#motivation"><span class="toc-section-number">1.1</span> Motivation</a></li>
<li><a href="#goals"><span class="toc-section-number">1.2</span> Goals</a></li>
<li><a href="#notation"><span class="toc-section-number">1.3</span> Notation</a></li>
<li><a href="#normative"><span class="toc-section-number">1.4</span> Normative</a></li>
</ul></li>
<li><a href="#common-definitions"><span class="toc-section-number">2</span> Common definitions</a><ul>
<li><a href="#characters"><span class="toc-section-number">2.1</span> Characters</a></li>
<li><a href="#boolean-constants"><span class="toc-section-number">2.2</span> Boolean constants</a></li>
<li><a href="#atomic-propositions"><span class="toc-section-number">2.3</span> Atomic Propositions</a></li>
<li><a href="#boolean-operators"><span class="toc-section-number">2.4</span> Boolean operators</a></li>
<li><a href="#parenthesis"><span class="toc-section-number">2.5</span> Parenthesis</a></li>
<li><a href="#white-spaces"><span class="toc-section-number">2.6</span> White Spaces</a></li>
</ul></li>
<li><a href="#ltl"><span class="toc-section-number">3</span> LTL</a><ul>
<li><a href="#atoms"><span class="toc-section-number">3.1</span> Atoms</a></li>
<li><a href="#temporal-operators"><span class="toc-section-number">3.2</span> Temporal operators</a></li>
<li><a href="#grammar"><span class="toc-section-number">3.3</span> Grammar</a></li>
<li><a href="#precedence-and-associativity-of-operators"><span class="toc-section-number">3.4</span> Precedence and associativity of operators</a></li>
</ul></li>
<li><a href="#ldl"><span class="toc-section-number">4</span> LDL</a><ul>
<li><a href="#temporal-operators-1"><span class="toc-section-number">4.1</span> Temporal operators</a></li>
<li><a href="#regular-expressions"><span class="toc-section-number">4.2</span> Regular Expressions</a></li>
<li><a href="#precedence-and-associativity-of-operators-1"><span class="toc-section-number">4.3</span> Precedence and associativity of operators</a></li>
</ul></li>
<li><a href="#future-work"><span class="toc-section-number">5</span> Future work</a></li>
<li><a href="#license"><span class="toc-section-number">6</span> License</a></li>
<li><a href="#references">References</a></li>
</ul>
</nav>
<center>
<h3>Abstract</h3>
<p class="abstract">
The heterogeneity of tools that support temporal logic formulae poses several challenges in terms of interoperability. This document proposes standard grammars for Linear Temporal Logic (LTL) <span class="citation" data-cites="pnueli77">(Pnueli 1977)</span> and Linear Dynamic Logic <span class="citation" data-cites="vardi2011rise degiacomo2013">(Vardi 2011; De Giacomo and Vardi 2013)</span>.
</center>
</p>
<hr />
<p>WARNING: this version (v0.1.0) is a draft. You are encouraged to email the contact author for any comment or suggestion.</p>
<hr />
<h1 id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>This section explains the motivations behind the existence of this standard, states the goals of the standard, describes the notation conventions used thorough the document, and lists the normative references<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<h2 id="motivation"><span class="header-section-number">1.1</span> Motivation</h2>
<p>Temporal logics have a long history <span class="citation" data-cites="konur2010">(Konur 2010)</span>. One of the most influential formalisms is Linear Temporal Logic (LTL) <span class="citation" data-cites="pnueli77">(Pnueli 1977)</span>, which has been applied for program specification and verification. The variant over finite traces has been introduced in <span class="citation" data-cites="degiacomo2013">(De Giacomo and Vardi 2013)</span>. Linear Dynamic Logic (LDL) <span class="citation" data-cites="vardi2011rise degiacomo2013">(Vardi 2011; De Giacomo and Vardi 2013)</span> is the extension of LTL with regular expressions (RE). The idea behind LDL is to have a formalism that merges the declarativeness and convenience of LTL, as expressive as star-free RE, with the expressive power of RE. The finite trace setting has been explored by <span class="citation" data-cites="degiacomo2013">(De Giacomo and Vardi 2013)</span> for LTL/LDL and <span class="citation" data-cites="degiacomo2020">(De Giacomo et al. 2020)</span> for PLTL/PLDL. The syntax that naturally supports empty traces has been employed in <span class="citation" data-cites="brafman2018">(Brafman, De Giacomo, and Patrizi 2018)</span> for LTL/LDL and <span class="citation" data-cites="degiacomo2020">(De Giacomo et al. 2020)</span> for PLTL/PLDL.</p>
<p>The topic has gained more and more attention both in academia and industry, also because such logics have been considered compelling also from a practical point of view. Among areas of Computer Science and Artificial Intelligence, we encounter reactive synthesis <span class="citation" data-cites="degiacomo2015">(De Giacomo and Vardi 2015)</span>, model checking <span class="citation" data-cites="clarke1986">(Clarke, Emerson, and Sistla 1986)</span>, planning with temporal goal <span class="citation" data-cites="bacchus1998planning">(Bacchus and Kabanza 1998)</span>, theory of Markov Decision Process with non-Markovian rewards <span class="citation" data-cites="bacchus1996rewarding">(Bacchus, Boutilier, and Grove 1996)</span>, business processes specification <span class="citation" data-cites="pevsic2010enacting">(Pešić, Bošnački, and Aalst 2010)</span>, just to name a few. For what concerns industry applications, Intel proposed the industrial linear time specification language <code>ForSpec</code> <span class="citation" data-cites="armoni2002forspec">(Armoni et al. 2002)</span>, and the IEEE association standardized the <em>Property Specification Language</em> (PSL) <span class="citation" data-cites="ieee2010">(IEEE 2010)</span>. Both standards witness the need of specifications based on LTL and regular expressions. Also, the research community has proposed a plethora of software tools and libraries to handle LTL and/or LDL formulas for a variety of purposes: <code>Spot</code> <span class="citation" data-cites="duret2016spot duret2016spotb">(Duret-Lutz 2016; Duret-Lutz et al. 2016)</span>, <code>Owl</code> <span class="citation" data-cites="owl2018">(Kretinsky, Meggendorfer, and Sickert 2018)</span>, <code>SPIN</code> <span class="citation" data-cites="holzmann2011">(Holzmann 2011)</span>, <code>Syft</code> <span class="citation" data-cites="Zhu_2017">(Zhu et al. 2017)</span>, <code>Lisa</code> <span class="citation" data-cites="bansal2020hybrid">(Bansal et al. 2020)</span>, <code>FLLOAT</code> <span class="citation" data-cites="flloat2015 favorito2018reinforcement">(De Masellis 2015; Favorito 2018)</span>, <code>LTLf2DFA</code> <span class="citation" data-cites="fuggitti_whitemechltlf2dfa_2018">(Fuggitti 2018)</span>, and more. Another related work is represented by TLSF v1.1 <span class="citation" data-cites="jacobs2016high">(Jacobs, Klein, and Schirmer 2016)</span>, although its focus is on a format for LTL synthesis problems.</p>
<p>All these tools and formats assume the input formulae to be written in a certain grammar. Unfortunately, as often happens when dealing with parser implementations with lack of coordination, the grammars to represent the formulae have some form of discrepancies; e.g. different alternative ways to denote boolean conjunctions or temporal operators, different lexical rules to describe the allowed atomic propositions or boolean constants, underspecifications on how to handle special characters (linefeed, tab, newline, etc.), how to handle associativity of the operators.</p>
<h2 id="goals"><span class="header-section-number">1.2</span> Goals</h2>
<p>To enhance interoperability between the aforementioned tools, this document proposes a standard grammar for writing temporal logic formulae. In particular, we specify grammars for:</p>
<ul>
<li>Linear Temporal Logic (LTL)</li>
<li>Linear Dynamic Logic (LDL)</li>
</ul>
<p>In future versions of this standard, we would like to provide grammars for:</p>
<ul>
<li>Past Linear Temporal Logic (PLTL)</li>
<li>Past Linear Dynamic Logic (PLDL)</li>
</ul>
<p>We would like this standard to be:</p>
<ul>
<li>An <em>open</em> standard, fostering collaboration and contributions from the research community;</li>
<li>As much compliant as possible to existing and widely used tools;</li>
<li>Written by researchers, for researchers. In other words, this is not strictly tight to industrial needs; for instance, we deliberately dropped the modeling of multiple clock and reset signals of <code>ForSpec</code> and <code>PSL</code>, as these are constructs not relevant for domains outside formal verification.</li>
<li>Tool-agnostic. Often, grammars are reported alongside software manuals and descriptions. Instead, our aim is to propose a common denominator for all the grammars in use.</li>
</ul>
<h2 id="notation"><span class="header-section-number">1.3</span> Notation</h2>
<p>We describe the syntax in Extended Backus-Naur Form (EBNF) <span class="citation" data-cites="backus1959syntax">(Backus 1959)</span>. We follow the notation used for the specification of XML <span class="citation" data-cites="xml">(W3C 2008)</span>; we discarded the EBNF standard version ISO/IEC 14977 <span class="citation" data-cites="iso1996iso">(ISO 1996)</span>, as it has been often rejected by the community of those who write language specifications for a variety of reasons <span class="citation" data-cites="david_dont_2020 zaytsev2012bnf">(Wheeler 2020; Zaytsev 2012)</span>.</p>
<h2 id="normative"><span class="header-section-number">1.4</span> Normative</h2>
<p>We refer to <span class="citation" data-cites="bradner1997key">(Bradner 1997)</span> for requirement level key words. We also refer to Unicode standard <span class="citation" data-cites="ISOUNICODE unicode2020">(ISO/IEC 2020; The Unicode Consortium 2020)</span> to define legal characters. For versioning this standard, we use SemVerDocs <span class="citation" data-cites="tekampe_semantic_nodate">(Tekampe 2018)</span>, inspired by SemVer <span class="citation" data-cites="preston-werner_semantic_nodate">(Preston-Werner 2011)</span>.</p>
<h1 id="common-definitions"><span class="header-section-number">2</span> Common definitions</h1>
<p>In this section, we describe syntactic rules shared across every logic formalism.</p>
<h2 id="characters"><span class="header-section-number">2.1</span> Characters</h2>
<p>Parsers MUST be able to accept sequence of <em>characters</em> (see definition below) which represent temporal logic formulae. A <em>character</em> is an atomic unit of text as specified by ISO/IEC 10646:2020 <span class="citation" data-cites="ISOUNICODE">(ISO/IEC 2020)</span>. Legal characters are tab, carriage return, line feed, and the ASCII characters of Unicode and ISO/IEC 10646.</p>
<p>The range of characters to be supported is defined as:</p>
<pre><code>Char ::= [#x9 | #xA | #xD | [#x20-#x7e]</code></pre>
<p>That is, the character tabulation, line feed, carriage return, and all the printable ASCII characters.</p>
<h2 id="boolean-constants"><span class="header-section-number">2.2</span> Boolean constants</h2>
<p>For LTL and PLTL, we use <code>true</code> and <code>false</code> to denote boolean constants. For LDL and PLDL, we make a further distinction between <em>propositional</em> booleans, denoted by <code>true</code> and <code>false</code>, and <em>logical</em> booleans, denoted by <code>tt</code> and <code>ff</code>.</p>
<pre><code>True  ::= &quot;true&quot;
False ::= &quot;false&quot;
TT    ::= &quot;tt&quot;
FF    ::= &quot;ff&quot;
PropBooleans  ::= TRUE | FALSE
LogicBooleans ::= TT | FF</code></pre>
<h2 id="atomic-propositions"><span class="header-section-number">2.3</span> Atomic Propositions</h2>
<p>An atomic proposition is a string of characters. In particular, it can be:</p>
<ul>
<li>any string of printable characters, excepted the quotation character used (see <code>QuotedName</code>)</li>
<li>any string of at least one character that starts with <code>[A-Za-z_]</code> and continues with <code>[A-Za-z0-9_]</code>.</li>
</ul>
<pre><code>NameStartChar ::= [A-Z] | [a-z] | &quot;_&quot;
NameChar ::= NameStartChar | [0-9]
Name ::= NameStartChar (NameChar)*
QuotedName ::= (&#39;&quot;&#39; [^&quot;\n\t\r]* &#39;&quot;&#39;) | (&quot;&#39;&quot; [^&#39;\n\t\r]* &quot;&#39;&quot;)
Atom ::= Name | QuotedName</code></pre>
<h2 id="boolean-operators"><span class="header-section-number">2.4</span> Boolean operators</h2>
<p>The supported boolean operations are: negation, conjunction, disjunction, implication, equivalence and exclusion.</p>
<p>Follows the list of characters used for each operator:</p>
<ul>
<li>negation: <code>!</code>, <code>~</code>;</li>
<li>conjunction: <code>&amp;</code>, <code>&amp;&amp;</code>;</li>
<li>disjunction: <code>|</code>, <code>||</code>;</li>
<li>implication: <code>-&gt;</code>, <code>=&gt;</code>;</li>
<li>equivalence: <code>&lt;-&gt;</code>, <code>&lt;=&gt;</code>;</li>
<li>exclusive disjunction: <code>^</code>;</li>
</ul>
<pre><code>Non   ::= &quot;!&quot; | &quot;~&quot;
And   ::= &quot;&amp;&quot; | &quot;&amp;&amp;&quot;
Or    ::= &quot;|&quot; | &quot;||&quot;
Impl  ::= &quot;-&gt;&quot; | &quot;=&gt;&quot;
Equiv ::= &quot;&lt;-&gt;&quot; | &quot;&lt;=&gt;&quot;
Xor   ::= &quot;^&quot;</code></pre>
<h2 id="parenthesis"><span class="header-section-number">2.5</span> Parenthesis</h2>
<p>We use <code>(</code> and <code>)</code> for parenthesis.</p>
<pre><code>LeftParen  ::= &quot;(&quot;
RightParen ::= &quot;)&quot;</code></pre>
<h2 id="white-spaces"><span class="header-section-number">2.6</span> White Spaces</h2>
<p>It is often convenient to use “white spaces” (spaces, tabs, and blank lines) to set apart the formulae for greater readability. These characters MUST be ignored when processing the text input.</p>
<h1 id="ltl"><span class="header-section-number">3</span> LTL</h1>
<p>In this section, we specify a grammar for LTL.</p>
<h2 id="atoms"><span class="header-section-number">3.1</span> Atoms</h2>
<p>An LTL formula is defined over a set of <em>atoms</em>. In this context, an atom formula is defined by using the <code>Atom</code> regular language defined above:</p>
<pre><code>LTLAtom ::= Atom</code></pre>
<h2 id="temporal-operators"><span class="header-section-number">3.2</span> Temporal operators</h2>
<p>Here we specify the regular languages for the temporal operators.</p>
<ul>
<li>(Weak) Next: <code>X</code>;</li>
<li>Strong Next: <code>X[!]</code>;</li>
<li>(Strong) Until: <code>U</code>;</li>
<li>Weak Until: <code>W</code>;</li>
<li>(Weak) Release: <code>R</code>, <code>V</code>;</li>
<li>Strong Release: <code>M</code>;</li>
<li>Eventually: <code>F</code>;</li>
<li>Always: <code>G</code>;</li>
</ul>
<p>In EBNF format:</p>
<pre><code>WeakNext      ::= &quot;X&quot;
Next          ::= &quot;X[!]&quot;
Until         ::= &quot;U&quot;
WeakUntil     ::= &quot;W&quot;
Release       ::= &quot;R&quot; | &quot;V&quot;
StrongRelease ::= &quot;M&quot;
Eventually    ::= &quot;F&quot;
Always        ::= &quot;G&quot;</code></pre>
<h2 id="grammar"><span class="header-section-number">3.3</span> Grammar</h2>
<pre><code>ltl_formula ::= LTLAtom
                | True
                | False
                | LeftParen ltl_formula RightParen 
                | Not ltl_formula 
                | ltl_formula And ltl_formula
                | ltl_formula Or ltl_formula
                | ltl_formula Impl ltl_formula
                | ltl_formula Equiv ltl_formula
                | ltl_formula Xor ltl_formula
                | ltl_formula Until ltl_formula
                | ltl_formula WeakUntil ltl_formula
                | ltl_formula Release ltl_formula
                | ltl_formula StrongRelease ltl_formula
                | Eventually ltl_formula
                | Always ltl_formula
                | WeakNext ltl_formula
                | Next ltl_formula</code></pre>
<p>For the semantics of these operators, we refer to <span class="citation" data-cites="pnueli77">(Pnueli 1977)</span> for the infinite setting, and <span class="citation" data-cites="degiacomo2013">(De Giacomo and Vardi 2013)</span> for the finite setting.</p>
<h2 id="precedence-and-associativity-of-operators"><span class="header-section-number">3.4</span> Precedence and associativity of operators</h2>
<p>The precedence and associativity of the LTL operators are described by the following table (priorities from lowest to highest). For brevity, aliases for boolean operators are omitted.</p>
<center>
<table>
<thead>
<tr class="header">
<th>associativity</th>
<th>operators</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>right</td>
<td><code>-&gt;</code>, <code>&lt;-&gt;</code></td>
</tr>
<tr class="even">
<td>left</td>
<td><code>^</code></td>
</tr>
<tr class="odd">
<td>left</td>
<td><code>|</code></td>
</tr>
<tr class="even">
<td>left</td>
<td><code>&amp;</code></td>
</tr>
<tr class="odd">
<td>right</td>
<td><code>U</code>,<code>W</code>,<code>M</code>,<code>R</code></td>
</tr>
<tr class="even">
<td>right</td>
<td><code>F</code>, <code>G</code></td>
</tr>
<tr class="odd">
<td>right</td>
<td><code>X</code>, <code>X[!]</code></td>
</tr>
<tr class="even">
<td>right</td>
<td><code>!</code></td>
</tr>
</tbody>
</table>
</center>
<h1 id="ldl"><span class="header-section-number">4</span> LDL</h1>
<p>In this section, we specify a grammar for LDL.</p>
<h2 id="temporal-operators-1"><span class="header-section-number">4.1</span> Temporal operators</h2>
<p>LDL supports two temporal operators:</p>
<ul>
<li><em>Diamond</em> operator: <code>&lt;regex&gt;ldl_formula</code>;</li>
<li><em>Box</em> operator: <code>[regex]ldl_formula</code>;</li>
</ul>
<p><code>regex</code> will be presented in the next paragraph.</p>
<pre><code>LeftDiam  ::= &quot;&lt;&quot;
RightDiam ::= &quot;&gt;&quot;
LeftBox   ::= &quot;[&quot;
RightBox  ::= &quot;]&quot;</code></pre>
<p>In EBNF format, an LDL formula is defined as follows:</p>
<pre><code>ldl_formula ::= TT
              | FF
              | LeftParen ldl_formula RightParen
              | Not ldl_formula 
              | ldl_formula And ldl_formula
              | ldl_formula Or ldl_formula
              | ldl_formula Impl ldl_formula
              | ldl_formula Equiv ldl_formula
              | LeftDiam regex RightDiam ldl_formula
              | LeftBox regex RightBox ldl_formula</code></pre>
<h2 id="regular-expressions"><span class="header-section-number">4.2</span> Regular Expressions</h2>
<p>In this section, we define the regular expression used by Diamond and Box operators.</p>
<p>A regular expression is defined inductively as:</p>
<ul>
<li>a <em>propositonal formula</em> over as set of propositional atoms.</li>
<li>a <em>test expression</em>: `ldl_formula?</li>
<li>a <em>concatenation</em> between two regular expressions: <code>regex_1 ; regex_2</code></li>
<li>a <em>union</em> between two regular expressions: <code>regex_1 + regex_2</code></li>
<li>a <em>star</em> operator over a regular expression: <code>regex*</code></li>
</ul>
<p>The symbols are listed below:</p>
<pre><code>Test   ::= &quot;?&quot;
Concat ::= &quot;;&quot;
Union  ::= &quot;+&quot;
Star   ::= &quot;*&quot;</code></pre>
<p>The EBNF grammar for a regular expression is:</p>
<pre><code>propositional ::= Atom
                  | True
                  | False
                  | LeftParen propositional RightParen 
                  | Not propositional 
                  | propositional And propositional
                  | propositional Or propositional
                  | propositional Impl propositional
                  | propositional Equiv propositional
                  | propositional Xor propositional

regex ::= propositional
          | LeftParen regex RightParen
          | regex Test
          | regex Concat regex 
          | regex Union regex 
          | regex Star</code></pre>
<p>For the semantics of the operators, we refer to <span class="citation" data-cites="degiacomo2013">(De Giacomo and Vardi 2013)</span>.</p>
<h2 id="precedence-and-associativity-of-operators-1"><span class="header-section-number">4.3</span> Precedence and associativity of operators</h2>
<p>The precedence and associativity of the LDL operators are described by the following table (priorities from lowest to highest). For brevity, aliases for boolean operators are omitted.</p>
<center>
<table>
<thead>
<tr class="header">
<th>associativity</th>
<th>operators</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>right</td>
<td><code>-&gt;</code>, <code>&lt;-&gt;</code></td>
</tr>
<tr class="even">
<td>left</td>
<td><code>^</code></td>
</tr>
<tr class="odd">
<td>left</td>
<td><code>|</code></td>
</tr>
<tr class="even">
<td>left</td>
<td><code>&amp;</code></td>
</tr>
<tr class="odd">
<td>N/A</td>
<td><code>&lt;&gt;</code>, <code>[]</code></td>
</tr>
<tr class="even">
<td>left</td>
<td><code>;</code></td>
</tr>
<tr class="odd">
<td>left</td>
<td><code>+</code></td>
</tr>
<tr class="even">
<td>left</td>
<td><code>*</code></td>
</tr>
<tr class="odd">
<td>left</td>
<td><code>?</code></td>
</tr>
<tr class="even">
<td>right</td>
<td><code>!</code></td>
</tr>
</tbody>
</table>
</center>
<h1 id="future-work"><span class="header-section-number">5</span> Future work</h1>
<p>In future versions of this standard, we would like to add:</p>
<ul>
<li><code>Spot</code>-like syntactic sugars for regular expressions (SERE) and temporal operators <span class="citation" data-cites="duret2016spot jacobs2016high">(Duret-Lutz 2016; Jacobs, Klein, and Schirmer 2016)</span>;</li>
<li>Compatibility with the PSL standard <span class="citation" data-cites="ieee2010">(IEEE 2010)</span>;</li>
<li>Support full Unicode characters, so to use UTF-8 characters like <span class="math inline">∘</span> (U+25CB) for the Next operator and <span class="math inline">⋄</span> (U+25C7) for the Eventually operator etc. as alternative symbols.</li>
<li>Grammars for PLTL and PLDL.</li>
</ul>
<h1 id="license"><span class="header-section-number">6</span> License</h1>
<p><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-armoni2002forspec">
<p>Armoni, Roy, Limor Fix, Alon Flaisher, Rob Gerth, Boris Ginsburg, Tomer Kanza, Avner Landver, et al. 2002. “The Forspec Temporal Logic: A New Temporal Property-Specification Language.” In <em>International Conference on Tools and Algorithms for the Construction and Analysis of Systems</em>, 296–311. Springer.</p>
</div>
<div id="ref-bacchus1996rewarding">
<p>Bacchus, Fahiem, Craig Boutilier, and Adam Grove. 1996. “Rewarding Behaviors.” In <em>Proceedings of the National Conference on Artificial Intelligence</em>, 1160–7.</p>
</div>
<div id="ref-bacchus1998planning">
<p>Bacchus, Fahiem, and Froduald Kabanza. 1998. “Planning for Temporally Extended Goals.” <em>Annals of Mathematics and Artificial Intelligence</em> 22 (1-2): 5–27.</p>
</div>
<div id="ref-backus1959syntax">
<p>Backus, John W. 1959. “The Syntax and Semantics of the Proposed International Algebraic Language of the Zurich Acm-Gamm Conference.” <em>Proceedings of the International Comference on Information Processing, 1959</em>.</p>
</div>
<div id="ref-bansal2020hybrid">
<p>Bansal, Suguman, Yong Li, Lucas M. Tabajara, and Moshe Y. Vardi. 2020. “Hybrid Compositional Reasoning for Reactive Synthesis from Finite-Horizon Specifications.” In <em>The Thirty-Fourth Aaai Conference on Artificial Intelligence, Aaai 2020, the Thirty-Second Innovative Applications of Artificial Intelligence Conference, Iaai 2020, the Tenth Aaai Symposium on Educational Advances in Artificial Intelligence, Eaai 2020, New York, Ny, Usa, February 7-12, 2020</em>, 9766–74. AAAI Press. <a href="https://aaai.org/ojs/index.php/AAAI/article/view/6528">https://aaai.org/ojs/index.php/AAAI/article/view/6528</a>.</p>
</div>
<div id="ref-bradner1997key">
<p>Bradner, Scott. 1997. “Key Words for Use in Rfcs to Indicate Requirement Levels.” <em>RFC2119</em>.</p>
</div>
<div id="ref-brafman2018">
<p>Brafman, Ronen, Giuseppe De Giacomo, and Fabio Patrizi. 2018. “LTLf/Ldlf Non-Markovian Rewards.” <a href="https://www.aaai.org/ocs/index.php/AAAI/AAAI18/paper/view/17342">https://www.aaai.org/ocs/index.php/AAAI/AAAI18/paper/view/17342</a>.</p>
</div>
<div id="ref-clarke1986">
<p>Clarke, E. M., E. A. Emerson, and A. P. Sistla. 1986. “Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications.” <em>ACM Trans. Program. Lang. Syst.</em> 8 (2): 244263. <a href="https://doi.org/10.1145/5397.5399">https://doi.org/10.1145/5397.5399</a>.</p>
</div>
<div id="ref-degiacomo2020">
<p>De Giacomo, Giuseppe, Antonio Di Stasio, Francesco Fuggitti, and Sasha Rubin. 2020. “Pure-Past Linear Temporal and Dynamic Logic on Finite Traces.” In <em>Twenty-Ninth International Joint Conference on Artificial Intelligence and Seventeenth Pacific Rim International Conference on Artificial Intelligence Ijcai-Pricai-20</em>. International Joint Conferences on Artificial Intelligence Organization. <a href="https://doi.org/10.24963/ijcai.2020/690">https://doi.org/10.24963/ijcai.2020/690</a>.</p>
</div>
<div id="ref-degiacomo2013">
<p>De Giacomo, Giuseppe, and Moshe Y. Vardi. 2013. “Linear Temporal Logic and Linear Dynamic Logic on Finite Traces.” In <em>Proceedings of the Twenty-Third International Joint Conference on Artificial Intelligence</em>, 854–60. IJCAI ’13. Beijing, China: AAAI Press. <a href="http://dl.acm.org/citation.cfm?id=2540128.2540252">http://dl.acm.org/citation.cfm?id=2540128.2540252</a>.</p>
</div>
<div id="ref-degiacomo2015">
<p>———. 2015. “Synthesis for Ltl and Ldl on Finite Traces.” In <em>Proceedings of the 24th International Conference on Artificial Intelligence</em>, 1558–64. IJCAI’15. Buenos Aires, Argentina: AAAI Press. <a href="http://dl.acm.org/citation.cfm?id=2832415.2832466">http://dl.acm.org/citation.cfm?id=2832415.2832466</a>.</p>
</div>
<div id="ref-flloat2015">
<p>De Masellis, Riccardo. 2015. “RiccardoDeMasellis/Flloat.” <a href="https://github.com/RiccardoDeMasellis/FLLOAT">https://github.com/RiccardoDeMasellis/FLLOAT</a>.</p>
</div>
<div id="ref-duret2016spot">
<p>Duret-Lutz, Alexandre. 2016. “Spot’s Temporal Logic Formulas.” Tech. rep. Available online: https://spot.lrde.epita.fr/tl.pdf.</p>
</div>
<div id="ref-duret2016spotb">
<p>Duret-Lutz, Alexandre, Alexandre Lewkowicz, Amaury Fauchille, Thibaud Michaud, Etienne Renault, and Laurent Xu. 2016. “Spot 2.0A Framework for Ltl and 19970\backslash 19970-Automata Manipulation.” In <em>International Symposium on Automated Technology for Verification and Analysis</em>, 122–29. Springer.</p>
</div>
<div id="ref-favorito2018reinforcement">
<p>Favorito, Marco. 2018. “Reinforcement Learning for Ltlf/Ldlf Goals: Theory and Implementation.” <em>Master’s Thesis. DIAG, Sapienza Univ. Rome</em>.</p>
</div>
<div id="ref-fuggitti_whitemechltlf2dfa_2018">
<p>Fuggitti, Francesco. 2018. “LTLf2DFA.” WhiteMech. <a href="https://github.com/whitemech/LTLf2DFA">https://github.com/whitemech/LTLf2DFA</a>.</p>
</div>
<div id="ref-holzmann2011">
<p>Holzmann, Gerard. 2011. <em>The Spin Model Checker: Primer and Reference Manual</em>. 1st ed. Addison-Wesley Professional.</p>
</div>
<div id="ref-ieee2010">
<p>IEEE. 2010. “IEEE Standard for Property Specification Language (Psl).” IEEE. <a href="https://doi.org/10.1109/ieeestd.2010.5446004">https://doi.org/10.1109/ieeestd.2010.5446004</a>.</p>
</div>
<div id="ref-iso1996iso">
<p>ISO, Extended BNF. 1996. “ISO/Iec 14977: 1996 (E).” <em>ISO: Geneva</em>.</p>
</div>
<div id="ref-ISOUNICODE">
<p>ISO/IEC. 2020. “Information Technology—Universal Coded Character Set.” ISO/IEC 10646:2020. Geneva, Switzerland: International Organization for Standardization.</p>
</div>
<div id="ref-jacobs2016high">
<p>Jacobs, Swen, Felix Klein, and Sebastian Schirmer. 2016. “A High-Level Ltl Synthesis Format: TLSF V1. 1.” <em>arXiv Preprint arXiv:1604.02284</em>.</p>
</div>
<div id="ref-konur2010">
<p>Konur, Savas. 2010. “A Survey on Temporal Logics,” May. <a href="http://arxiv.org/abs/1005.3199v3">http://arxiv.org/abs/1005.3199v3</a>.</p>
</div>
<div id="ref-owl2018">
<p>Kretinsky, Jan, Tobias Meggendorfer, and Salomon Sickert. 2018. “Owl: A Library for Omega-Words, Automata, and Ltl.” In <em>Automated Technology for Verification and Analysis - 16th International Symposium, Atva 2018, Los Angeles, ca, Usa, October 7-10, 2018, Proceedings</em>, edited by Shuvendu K. Lahiri and Chao Wang, 11138:543–50. Lecture Notes in Computer Science. Springer. <a href="https://doi.org/10.1007/978-3-030-01090-4\textbackslash{}\_34">https://doi.org/10.1007/978-3-030-01090-4\textbackslash{}\_34</a>.</p>
</div>
<div id="ref-pevsic2010enacting">
<p>Pešić, Maja, Dragan Bošnački, and Wil MP van der Aalst. 2010. “Enacting Declarative Languages Using Ltl: Avoiding Errors and Improving Performance.” In <em>International Spin Workshop on Model Checking of Software</em>, 146–61. Springer.</p>
</div>
<div id="ref-pnueli77">
<p>Pnueli, Amir. 1977. “The Temporal Logic of Programs.” In <em>18th Annual Symposium on Foundations of Computer Science (Sfcs 1977)</em>. IEEE. <a href="https://doi.org/10.1109/sfcs.1977.32">https://doi.org/10.1109/sfcs.1977.32</a>.</p>
</div>
<div id="ref-preston-werner_semantic_nodate">
<p>Preston-Werner, Tom. 2011. “Semantic Versioning 2.0.0.” <em>Semantic Versioning</em>. <a href="https://semver.org/">https://semver.org/</a>.</p>
</div>
<div id="ref-tekampe_semantic_nodate">
<p>Tekampe, Nils. 2018. “Semantic Versioning for Documents 1.0.0.” <em>SemVerDoc</em>. <a href="https://semverdoc.org/semverdoc.html">https://semverdoc.org/semverdoc.html</a>.</p>
</div>
<div id="ref-unicode2020">
<p>The Unicode Consortium. 2020. <em>The Unicode Standard, Version 13.0.0</em>. <a href="https://www.unicode.org/versions/Unicode13.0.0/">https://www.unicode.org/versions/Unicode13.0.0/</a>.</p>
</div>
<div id="ref-vardi2011rise">
<p>Vardi, Moshe Y. 2011. “The Rise and Fall of Ltl.” <em>GandALF</em> 54.</p>
</div>
<div id="ref-xml">
<p>W3C. 2008. “Extensible Markup Language (Xml) 1.0 (Fifth Edition).” <a href="https://www.w3.org/TR/xml/">https://www.w3.org/TR/xml/</a>.</p>
</div>
<div id="ref-david_dont_2020">
<p>Wheeler, David. 2020. “Don’t Use Iso/Iec 14977 Extended Backus-Naur Form (Ebnf).” <a href="https://dwheeler.com/essays/dont-use-iso-14977-ebnf.html">https://dwheeler.com/essays/dont-use-iso-14977-ebnf.html</a>.</p>
</div>
<div id="ref-zaytsev2012bnf">
<p>Zaytsev, Vadim. 2012. “BNF Was Here: What Have We Done About the Unnecessary Diversity of Notation for Syntactic Definitions.” In <em>Proceedings of the 27th Annual Acm Symposium on Applied Computing</em>, 1910–5.</p>
</div>
<div id="ref-Zhu_2017">
<p>Zhu, Shufang, Lucas M. Tabajara, Jianwen Li, Geguang Pu, and Moshe Y. Vardi. 2017. “Symbolic Ltlf Synthesis.” <em>Proceedings of the Twenty-Sixth International Joint Conference on Artificial Intelligence</em>, August. <a href="https://doi.org/10.24963/ijcai.2017/189">https://doi.org/10.24963/ijcai.2017/189</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>You can get the sources of this document at this repository: <a href="https://github.com/marcofavorito/tl-grammars">https://github.com/marcofavorito/tl-grammars</a><a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>
</body>
</html>
